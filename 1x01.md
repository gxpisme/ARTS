# 第一周

## Algorithm

### 字符串替换
https://leetcode.com/problems/defanging-an-ip-address/submissions/

这个题比较简单，总结来说就是字符串替换。

```
class Solution {
    public String defangIPaddr(String address) {
        String ret = "";
        if (address.length() < 1) {
            return ret;
        }

        for (int i = 0; i < address.length(); i++) {
            char c = address.charAt(i);
            if (c == '.') {
                ret += "[.]";
            } else {
                ret += c;
            }
        }

        return ret;
    }
}
```

### 比较大小
https://leetcode.com/problems/peak-index-in-a-mountain-array/

给定一个数组，数组长度大于等于3，数组是先从小到大排序，然后再从大到小排序，找到这个临界点的index。
其实本质上就是比较，第i个数，比i+1个数大即可。
```
class Solution {
    public int peakIndexInMountainArray(int[] A) {
        Integer len = A.length - 1;

        for (int i = 0; i < len; i++) {
            if (A[i] > A[i+1]) {
                return i;
            }
        }

        return 0;
    }
}
```

### SQL 使用
https://leetcode.com/problems/trips-and-users/

```
SELECT request_at                    AS Day,
       Round(Sum(CASE
                   WHEN status IN ( "cancelled_by_client", "cancelled_by_driver")
                   THEN 1 ELSE 0
                 END) / Count(*), 2) AS "Cancellation Rate"
FROM   trips AS t
       LEFT JOIN users AS u
              ON u.users_id = t.client_id
WHERE  banned = "no"
       AND request_at BETWEEN "2013-10-01" AND "2013-10-03"
GROUP  BY request_at;
```

### 将字符串转化为平铺的锯齿形状
https://leetcode.com/problems/zigzag-conversion/submissions/

核心思想按照平铺进行遍历，先向下一行行遍历，遍历达到numRows，然后在向右移动一行行遍历

```java
class Solution {
    public String convert(String s, int numRows) {
        if (numRows <= 1) {
            return s;
        }
        Integer len = s.length();
        HashMap<Integer, List<String>> map = new HashMap<>(numRows+1);

        //横
        Integer cross = 1;
        //竖
        Integer vertical = 1;
        //s的index
        Integer strIndex = 0;

        while (true) {
            if (strIndex >= len) {
                break;
            }

            // 如果竖的值都为1 则取字符串s的数据
            // 如果横+竖为numRos+1 则也许字符串s的数据
            if ((vertical == 1) || (vertical + cross == (numRows + 1))) {
                String s2 = String.valueOf(s.charAt(strIndex));
                List<String> strings = map.get(cross) == null ? new ArrayList<>() : map.get(cross);
                strings.add(s2);
                map.put(cross, strings);
                strIndex++;
            }

            cross++;
            if (cross.equals(numRows + 1)) {
                cross = 1;
                vertical++;
            }
            if (vertical.equals(numRows)) {
                vertical = 1;
            }
        }

        StringBuilder sb = new StringBuilder();


        map.forEach((integer, strings) -> {
            strings.forEach(e -> {
                sb.append(e);
            });
        });

        return sb.toString();
    }
}
```

## Review

## Tip

## Share
